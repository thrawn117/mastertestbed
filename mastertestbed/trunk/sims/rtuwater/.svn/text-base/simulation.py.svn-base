#!/usr/bin/env python

"""
@author Brad Reaves
@version 0.1
February 2011
@license GPL2

This module defines the necessary functions, constants, and variables to
simulate a simple fluid tank consisting of a single output valve and
single input pump governed by a single virtual device and monitored by a second
virtual device.
"""
import copy
import logging, optparse
import threading, Queue 
import time  
from math import sqrt
from configobj import ConfigObj

from protolibs import ifaces

#--------------- Parse Configuration Options ----------------

#Required Items:
#---Communication interface
    #Type (udp, tcp, pipes, serial)
    #Setup options (ports, filenames, destination addresses, etc)
#---Virtual Device Setup

#Simulation Details (constants, etc)
#   physical constants
#   simulation time
#   variables and default values
class Simulation():
    """This class obtains simulation information from a configuration file,
        sets up a simulation state, provides a method to step the simulation
        forward in time.
     """
    def readConfig(self):
        """Opens and parses the configuration file in the local directory. The
            results are available in self.config ."""
        ##Open ConfigFile
        self.config=ConfigObj(infile='sims/rtuwater/config', unrepr=True)

    def __init__(self):
        """Constructor for the simulation class. Calls readConfig() and 
        creates an initial simulation state."""
        self.readConfig()
        #/define/ comm interface type (based on config)
        ifaceinfo = self.config['simiface']
        ifacetype = getattr(ifaces, ifaceinfo['typ'])
        self.interface=ifacetype(**ifaceinfo)
        self.interface.initialize()

        #initialize variables in the procVarDictionary
        #   use a deep copy so that we can't change the config dictionary
        self.simState = copy.deepcopy(self.config['sim_state'])
        self.simState['simtime'] = time.time()

        self.pump_list = [] #BRDEBUG

    def step(self, upto=None):
        """Function that modifies the simulation state from the curent
        simulation state to the time given in parameter upto.
        
        @param upto Time to simulate from simState['simtime'] to upto.
                    upto should be a float in the format of the time.time()
                    call -- i.e. unix time. If upto is None, the current time 
                    will be used.
        """
        raw2percent = lambda l: ((l-3563.0)/3518)*100
        #percent2raw = lambda l: int((l/100.0)*3518 + 3563.0)
        percent2raw = lambda l: (l/100.0)*3518 + 3563.0
        
        if upto is None:
            upto = time.time()
        deltaT = upto - self.simState['simtime'] 
        if deltaT < 0:
            #This happens when we receive an update packet dated from before the
            #   current simulation time. In that case, we return to let the
            #   changes be applied, and then the simulation will step to the
            #   current time, and all will be well. In the worst case, changes
            #   should only be 100 ms old.
            return
        consts = self.config['sim_constants']
        
        #We're doing a simple model that's linear over time. Non-linear models
        #   may require iterating over fractions deltaT to be accurate.
        #   Numerical techniques from Sage or SciPy may be required for advanced
        #   models.

        level_percent = raw2percent(self.simState['LevelRawInputReg'])

        if self.simState['PumpRunCmd']:
            level_change = deltaT * self.pump_on_derivative(
                                        self.pump_on_inverse(level_percent))
        else:
            level_change = deltaT * self.pump_off_derivative(
                                        self.pump_off_inverse(level_percent))

        level_percent = level_percent + level_change 
        if level_percent <= consts['minimum_level']:
            level_percent = consts['minimum_level']
        elif level_percent > consts['maximum_level']:
            level_percent = consts['maximum_level']

        self.simState['LevelRawInputReg'] = percent2raw(level_percent)
        self.simState['simtime'] = upto

    def pump_on_derivative(self,t):
        """Returns the rate of change in the level at a given time"""
        return 1.248e-5*t**2 -.005013*t +.9097
    def pump_off_derivative(self, t):
        return .0004894*t -.478
        
    def pump_on_inverse(self, level):
        """Returns a time associated with the time/level curve.
        Code generated by Mathematica."""
        t = ( 200.83313306096292 - 3.082037376623253e24/
        pow(-9.286839548678612e66 + 1.0209084271727317e65*level 
            + 1.0209084271727317e65*sqrt(10661.354043359404 -
            181.93286099904697*level + pow(level,2)),
        0.3333333333333333) 
        + 1.0558328416631367e-20 *pow(-9.286839548678612e66 
                + 1.0209084271727317e65*level +
        1.0209084271727317e65*sqrt(10661.354043359404 - 181.93286099904697*level 
            + pow(level,2)),  0.3333333333333333))
        return t

    def pump_off_inverse(self, level):
        """Returns a time associated with the time/level curve.
        Code generated by Mathematica."""
        t = (5.106140419497046e-11*(1.911244999e13 
         - 2827.868632026601*sqrt(2.6074907603491004e19 
         + 1.9584263609e17*level)))
        return t


